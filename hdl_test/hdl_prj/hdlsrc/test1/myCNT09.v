// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\test1\myCNT09.v
// Created: 2023-10-04 18:26:37
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// CNT1_OUT                      ce_out        1
// OV                            ce_out        1
// CNT2_OUT                      ce_out        1
// FIR_OUT                       ce_out        1
// WAVE_OV                       ce_out        1
// FIR_OV                        ce_out        1
// WAVE_READY                    ce_out        1
// WAV_OUT                       ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: myCNT09
// Source Path: test1/myCNT09
// Hierarchy Level: 0
// Model version: 1.17
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module myCNT09 (
    clk,
    reset,
    clk_enable,
    ce_out,
    CNT1_OUT,
    OV,
    CNT2_OUT,
    FIR_OUT,
    WAVE_OV,
    FIR_OV,
    WAVE_READY,
    WAV_OUT
);


  input clk;
  input reset;
  input clk_enable;
  output ce_out;
  output [7:0] CNT1_OUT;  // uint8
  output OV;
  output [7:0] CNT2_OUT;  // uint8
  output signed [15:0] FIR_OUT;  // sfix16_En14
  output WAVE_OV;
  output FIR_OV;
  output WAVE_READY;
  output signed [15:0] WAV_OUT;  // sfix16_En15


  wire               enb;
  wire        [ 7:0] Constant_out1;  // uint8
  wire        [ 7:0] Constant1_out1;  // uint8
  wire        [ 7:0] Constant2_out1;  // uint8
  reg         [ 7:0] Delay_out1;  // uint8
  wire        [ 7:0] Add_out1;  // uint8
  wire               Relational_Operator_relop1;
  wire               switch_compare_1;
  wire        [ 7:0] Switch_out1;  // uint8
  wire               EQU1_relop1;
  wire        [ 7:0] count_step;  // uint8
  wire        [ 7:0] count_from;  // uint8
  reg         [ 7:0] HDL_Counter_out1;  // uint8
  wire        [ 7:0] count;  // uint8
  wire               need_to_wrap;
  wire        [ 7:0] count_value;  // uint8
  wire        [ 7:0] count_1;  // uint8
  wire signed [15:0] Constant3_out1;  // sfix16_En15
  wire               ConstantWE_out1;
  wire signed [15:0] RAM_out1;  // sfix16_En15
  reg         [ 1:0] D2CLK_reg;  // ufix1 [2]
  wire               D2CLK_out1;
  wire signed [15:0] Discrete_FIR_Filter_out1;  // sfix16_En14
  wire               Discrete_FIR_Filter_out2;
  wire               Discrete_FIR_Filter_out3;
  reg signed  [15:0] D2CLK1_bypass_delay;  // sfix16
  reg signed  [15:0] D2CLK1_reg;  // sfix16
  wire signed [15:0] D2CLK1_out1;  // sfix16_En14
  reg                FOUTDLY_out1;


  assign Constant_out1              = 8'b00000001;



  assign Constant1_out1             = 8'b00111111;



  assign Constant2_out1             = 8'b00000000;



  assign enb                        = clk_enable;

  assign Add_out1                   = Constant_out1 + Delay_out1;



  assign Relational_Operator_relop1 = Add_out1 <= Constant1_out1;



  assign switch_compare_1           = Relational_Operator_relop1 == 1'b1;



  assign Switch_out1                = (switch_compare_1 == 1'b0 ? Constant2_out1 : Add_out1);



  always @(posedge clk or posedge reset) begin : Delay_process
    if (reset == 1'b1) begin
      Delay_out1 <= 8'b00000000;
    end else begin
      if (enb) begin
        Delay_out1 <= Switch_out1;
      end
    end
  end



  assign CNT1_OUT     = Delay_out1;

  assign EQU1_relop1  = Delay_out1 == Constant1_out1;



  assign OV           = EQU1_relop1;

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 255
  assign count_step   = 8'b00000001;



  assign count_from   = 8'b00000000;



  assign count        = HDL_Counter_out1 + count_step;



  assign need_to_wrap = HDL_Counter_out1 == 8'b11111111;



  assign count_value  = (need_to_wrap == 1'b0 ? count : count_from);



  assign count_1      = (EQU1_relop1 == 1'b0 ? HDL_Counter_out1 : count_value);



  always @(posedge clk or posedge reset) begin : HDL_Counter_process
    if (reset == 1'b1) begin
      HDL_Counter_out1 <= 8'b00000000;
    end else begin
      if (enb) begin
        HDL_Counter_out1 <= count_1;
      end
    end
  end



  assign CNT2_OUT        = HDL_Counter_out1;

  assign Constant3_out1  = 16'sb0000000000000000;



  assign ConstantWE_out1 = 1'b0;



  SinglePortRAM_generic #(
      .AddrWidth(8),
      .DataWidth(16)
  ) u_RAM (
      .clk (clk),
      .enb (clk_enable),
      .din (Constant3_out1),
      .addr(HDL_Counter_out1),
      .we  (ConstantWE_out1),
      .dout(RAM_out1)
  );

  always @(posedge clk or posedge reset) begin : D2CLK_process
    if (reset == 1'b1) begin
      D2CLK_reg <= {2{1'b0}};
    end else begin
      if (enb) begin
        D2CLK_reg[0] <= EQU1_relop1;
        D2CLK_reg[1] <= D2CLK_reg[0];
      end
    end
  end

  assign D2CLK_out1 = D2CLK_reg[1];



  Discrete_FIR_Filter u_Discrete_FIR_Filter (
      .clk     (clk),
      .reset   (reset),
      .enb     (clk_enable),
      .dataIn  (RAM_out1),                  // sfix16_En15
      .validIn (D2CLK_out1),
      .dataOut (Discrete_FIR_Filter_out1),  // sfix16_En14
      .validOut(Discrete_FIR_Filter_out2),
      .ready   (Discrete_FIR_Filter_out3)
  );

  always @(posedge clk or posedge reset) begin : D2CLK1_process
    if (reset == 1'b1) begin
      D2CLK1_bypass_delay <= 16'sb0000000000000000;
      D2CLK1_reg          <= 16'sb0000000000000000;
    end else begin
      if (enb && Discrete_FIR_Filter_out2) begin
        D2CLK1_bypass_delay <= D2CLK1_reg;
        D2CLK1_reg          <= Discrete_FIR_Filter_out1;
      end
    end
  end

  assign D2CLK1_out1 = (Discrete_FIR_Filter_out2 == 1'b1 ? D2CLK1_reg : D2CLK1_bypass_delay);



  assign FIR_OUT     = D2CLK1_out1;

  assign WAVE_OV     = D2CLK_out1;

  always @(posedge clk or posedge reset) begin : FOUTDLY_process
    if (reset == 1'b1) begin
      FOUTDLY_out1 <= 1'b0;
    end else begin
      if (enb) begin
        FOUTDLY_out1 <= Discrete_FIR_Filter_out2;
      end
    end
  end



  assign FIR_OV     = FOUTDLY_out1;

  assign WAVE_READY = Discrete_FIR_Filter_out3;

  assign WAV_OUT    = RAM_out1;

  assign ce_out     = clk_enable;

endmodule  // myCNT09

